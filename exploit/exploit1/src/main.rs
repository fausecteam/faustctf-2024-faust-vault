use cipher::block_padding::UnpadError;
use rand::prelude::*;
use rand_chacha::ChaCha8Rng;
use aes::cipher::{block_padding::Pkcs7, BlockDecryptMut, KeyIvInit};
use reqwest::Url;
use serde_derive::{Deserialize, Serialize};
use chrono::{FixedOffset, TimeZone};
use std::str;

const NUMBER_OF_BITS_AES: usize = 192;
const NUMBER_OF_BYTES_AES: usize = NUMBER_OF_BITS_AES / 8;
const MAXIMUM_OFFSET_SECONDS: usize = 5;

#[derive(Serialize, Deserialize, Debug)]
struct CommunityEntry {
    group: String,
    createdAt: u64,
}

#[derive(Serialize, Deserialize, Debug)]
struct KeyValuePair {
    key: String,
    value: String,
}

fn generate_master_key(input: Box<[String]>) -> Box<[u8; NUMBER_OF_BYTES_AES]> {
    
    let username = &input[0];
    let registry_time = &input[1];

    let hash_seed: u64 = cityhasher::hash(format!("{username}{registry_time}"));
    Box::new(generate_aes_key(hash_seed))
}

fn generate_aes_key(seed: u64) -> [u8; NUMBER_OF_BYTES_AES] {
    let mut rng: ChaCha8Rng = ChaCha8Rng::seed_from_u64(seed);
    let mut aes_key_bytes : [u8; NUMBER_OF_BYTES_AES] = [0;NUMBER_OF_BYTES_AES];

    for byte in 0..NUMBER_OF_BYTES_AES {
        aes_key_bytes[byte] = rng.gen::<u8>();
    }
    aes_key_bytes
}

async fn get_date(hostname: String, port: i32, username: String) -> Result<u64, Box<dyn std::error::Error>> {
    let url = format!("http://{hostname}:{port}/api/store/");

    let url = format!("{url}/");
    let url = Url::parse(&*url)?;
    let res = reqwest::get(url).await?.json::<Vec<CommunityEntry>>().await?;
    if let Some(entry) = res.iter().find(|e| e.group == username) {
        Ok(entry.createdAt)
    } else {
        Err("Not found!".into())
    }
}

async fn get_secret(hostname: String, port: i32, username: String, secret: String) -> Result<String, Box<dyn std::error::Error>> {
    let url = format!("http://{hostname}:{port}/api/store/");

    let url = format!("{url}/{username}/{secret}");
    let url = Url::parse(&*url)?;
    let res = reqwest::get(url).await?.json::<KeyValuePair>().await?;
    Ok(res.value)
}

fn decrypt_aes(cipher_text: &[u8], key: &[u8]) ->  Result<Vec<u8>, UnpadError> {
    let iv = [0x42; 16];
    type Aes192CbcDec = cbc::Decryptor<aes::Aes192>;
    
    Aes192CbcDec::new(key.into(), &iv.into())
                        .decrypt_padded_vec_mut::<Pkcs7>(cipher_text)

}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let hostname = "localhost".to_string();
    let port = 5555;
    let username = "test".to_string();
    let secret = "flag".to_string();
   
    let enc_flag = get_secret(hostname.clone(), port, username.clone(), secret).await?;
    
    let date = get_date(hostname.clone(), port, username.clone()).await?;
    let mut current_timestamp: u64;
    // The known 2 hour time offset in seconds to UTC
    let tz_offset = FixedOffset::east(2 * 3600);

    let mut date_time;
    let mut offset_u64: u64;
    let mut masterkey = Box::new([0u8; NUMBER_OF_BYTES_AES]);
    let prepend_bytes = [0u8,1,2,3,4];
    let mut prepended_masterkey = [0u8; NUMBER_OF_BYTES_AES+5];
    prepended_masterkey[0..5].clone_from_slice(&prepend_bytes);
    for offset in 0..MAXIMUM_OFFSET_SECONDS {
        offset_u64 = offset as u64;
        current_timestamp = date - offset_u64;

        date_time = tz_offset.timestamp_opt(current_timestamp as i64, 0).unwrap().format("%l:%M:%S %p").to_string();
        println!("Time converted: {}", date_time.trim());
        masterkey = generate_master_key(Box::new([username.clone(), date_time.trim().to_string()]));
        //println!("Masterkey: {:?}", masterkey);
        prepended_masterkey[5..].clone_from_slice(&*masterkey);
        //println!("Prepended masterkey: {:?}", prepended_masterkey);

        //println!("Flag encrypted: {:?}", enc_flag);
        //println!("Flag encrypted as bytes: {:?}", enc_flag.as_bytes());
        let hex_decoded_flag = hex::decode(&enc_flag).expect("Decoding failed").into_boxed_slice();
        //println!("Hex-decoded flag: {:?}", hex_decoded_flag);

        let decryption_result = decrypt_aes(&hex_decoded_flag, &*masterkey);

        let decryption_result = match decryption_result {
            Err(_) => { println!("Probably wrong time! Skipping..."); continue },
            Ok(value) => { println!("Found correct time!"); value}
        };

        let flag = str::from_utf8(&decryption_result).unwrap();
        println!("Secret: {:?}", flag);

        break;

    }
    
    println!("Masterkey: {:?}", masterkey);
    Ok(())

}
